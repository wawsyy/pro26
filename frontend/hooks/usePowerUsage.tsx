"use client";

import { ethers } from "ethers";
import {
  RefObject,
  useCallback,
  useEffect,
  useMemo,
  useRef,
  useState,
} from "react";

import { FhevmInstance } from "@/fhevm/fhevmTypes";
import { FhevmDecryptionSignature } from "@/fhevm/FhevmDecryptionSignature";
import { GenericStringStorage } from "@/fhevm/GenericStringStorage";

// These will be generated by genabi script after deployment
// Try to import generated files, fallback to placeholder if not available
let PowerUsageABI_Module: any;
let PowerUsageAddresses_Module: any;

try {
  PowerUsageABI_Module = require("@/abi/PowerUsageABI");
  PowerUsageAddresses_Module = require("@/abi/PowerUsageAddresses");
} catch (error) {
  console.warn("Contract ABI files not found. Make sure to run deployment and genabi script first.", error);
  // Files not generated yet - will be available after deployment and genabi
  PowerUsageABI_Module = { PowerUsageABI: { abi: [] } };
  PowerUsageAddresses_Module = { PowerUsageAddresses: {} };
}

type PowerUsageABI = any[];
type PowerUsageAddresses = Record<string, { address: string; chainId: number; chainName?: string }>;

const PowerUsageABI_Data = PowerUsageABI_Module.PowerUsageABI?.abi || [];
const PowerUsageAddresses_Data = PowerUsageAddresses_Module.PowerUsageAddresses || {};

export type PowerRecord = {
  recordId: number;
  encryptedUsage: string;
  timestamp: number;
  period: number;
  decryptedValue?: number;
};

type PowerUsageInfoType = {
  abi: PowerUsageABI;
  address?: `0x${string}`;
  chainId?: number;
  chainName?: string;
};

function getPowerUsageByChainId(
  chainId: number | undefined
): PowerUsageInfoType {
  if (!chainId) {
    return { abi: PowerUsageABI_Data };
  }

  const entry = PowerUsageAddresses_Data[chainId.toString()];

  if (!entry || entry.address === ethers.ZeroAddress) {
    return { abi: PowerUsageABI_Data, chainId };
  }

  return {
    address: entry.address as `0x${string}` | undefined,
    chainId: entry.chainId ?? chainId,
    chainName: entry.chainName,
    abi: PowerUsageABI_Data,
  };
}

export const usePowerUsage = (parameters: {
  instance: FhevmInstance | undefined;
  fhevmDecryptionSignatureStorage: GenericStringStorage;
  chainId: number | undefined;
  ethersSigner: ethers.JsonRpcSigner | undefined;
  ethersReadonlyProvider: ethers.ContractRunner | undefined;
  sameChain: RefObject<(chainId: number | undefined) => boolean>;
  sameSigner: RefObject<
    (ethersSigner: ethers.JsonRpcSigner | undefined) => boolean
  >;
  userAddress?: string; // Add userAddress as a stable dependency
}) => {
  const {
    instance,
    fhevmDecryptionSignatureStorage,
    chainId,
    ethersSigner,
    ethersReadonlyProvider,
    sameChain,
    sameSigner,
    userAddress,
  } = parameters;

  const [records, setRecords] = useState<PowerRecord[]>([]);
  const [isLoading, setIsLoading] = useState<boolean>(false);
  const [isSubmitting, setIsSubmitting] = useState<boolean>(false);
  const [isDecrypting, setIsDecrypting] = useState<number | null>(null);
  const [message, setMessage] = useState<string>("");

  const powerUsageRef = useRef<PowerUsageInfoType | undefined>(undefined);
  const isLoadingRef = useRef<boolean>(false);
  const isSubmittingRef = useRef<boolean>(false);

  const powerUsage = useMemo(() => {
    const c = getPowerUsageByChainId(chainId);
    powerUsageRef.current = c;
    if (!c.address) {
      setMessage(`PowerUsage deployment not found for chainId=${chainId}.`);
    }
    return c;
  }, [chainId]);

  const isDeployed = useMemo(() => {
    if (!powerUsage) {
      return undefined;
    }
    return Boolean(powerUsage.address) && powerUsage.address !== ethers.ZeroAddress;
  }, [powerUsage]);

  const canSubmit = useMemo(() => {
    // Check if all required components are available
    const hasAddress = Boolean(powerUsage.address && powerUsage.address !== ethers.ZeroAddress);
    // Don't require instance here - we'll check it in submitRecord
    // This allows button to be enabled even if FHEVM is still initializing
    const hasSigner = ethersSigner !== undefined && ethersSigner !== null;
    const notBusy = !isSubmitting && !isLoading;
    
    const result = hasAddress && hasSigner && notBusy;
    return result;
  }, [powerUsage.address, ethersSigner, isSubmitting, isLoading]);

  const canLoadRecords = useMemo(() => {
    return powerUsage.address && ethersReadonlyProvider && ethersSigner && !isLoading;
  }, [powerUsage.address, ethersReadonlyProvider, ethersSigner, isLoading]);

  const hasLoadedRef = useRef(false);
  const lastAddressRef = useRef<string | undefined>(undefined);

  const loadUserRecords = useCallback(async () => {
    if (isLoadingRef.current) return;

    if (!powerUsageRef.current?.address || !ethersReadonlyProvider || !ethersSigner) {
      return;
    }

    isLoadingRef.current = true;
    setIsLoading(true);

    try {
      const contract = new ethers.Contract(
        powerUsageRef.current.address,
        powerUsageRef.current.abi,
        ethersReadonlyProvider
      );

      // Ensure signer is available and get address
      if (!ethersSigner) {
        setMessage("Signer not available");
        return;
      }

      const userAddress = await ethersSigner.getAddress();
      const recordIds = await contract.getUserRecords(userAddress);
      const recordCount = recordIds.length;

      const loadedRecords: PowerRecord[] = [];

      for (let i = 0; i < recordCount; i++) {
        const recordId = Number(recordIds[i]);
        const [owner, timestamp, period] = await contract.getRecordMetadata(recordId);
        const encryptedUsage = await contract.getRecordUsage(recordId);

        loadedRecords.push({
          recordId,
          encryptedUsage,
          timestamp: Number(timestamp),
          period: Number(period),
        });
      }

      setRecords(loadedRecords);
      hasLoadedRef.current = true;
      lastAddressRef.current = userAddress;
    } catch (e) {
      setMessage("Failed to load records: " + e);
    } finally {
      isLoadingRef.current = false;
      setIsLoading(false);
    }
  }, [ethersReadonlyProvider, ethersSigner]);

  // Only auto-load once when wallet connects or address changes
  useEffect(() => {
    if (!canLoadRecords || !userAddress) {
      hasLoadedRef.current = false;
      lastAddressRef.current = undefined;
      return;
    }

    const addressChanged = lastAddressRef.current !== userAddress;
    const shouldLoad = !hasLoadedRef.current || addressChanged;

    if (shouldLoad && !isLoadingRef.current) {
      lastAddressRef.current = userAddress;
      const timer = setTimeout(() => {
        loadUserRecords();
      }, 1000); // Wait 1 second after connection
      return () => clearTimeout(timer);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [powerUsage.address, userAddress]); // Only depend on contract address and user address

  const submitRecord = useCallback(
    async (powerUsageValue: number, period: number) => {
      if (isSubmittingRef.current || isLoadingRef.current) return;

      if (!powerUsage.address || !ethersSigner || powerUsageValue <= 0) {
        setMessage("Missing required components for submission");
        return;
      }

      // Check instance at submission time
      if (!instance) {
        setMessage("FHEVM instance is not ready yet. Please wait...");
        return;
      }

      const thisChainId = chainId;
      const thisPowerUsageAddress = powerUsage.address;
      const thisEthersSigner = ethersSigner;

      isSubmittingRef.current = true;
      setIsSubmitting(true);
      setMessage(`Encrypting and submitting ${powerUsageValue} kWh...`);

      const run = async () => {
        const isStale = async () => {
          if (thisPowerUsageAddress !== powerUsageRef.current?.address) return true;
          if (!sameChain.current(thisChainId)) return true;
          const same = await sameSigner.current(thisEthersSigner);
          return !same;
        };

        try {
          await new Promise((resolve) => setTimeout(resolve, 100));

          // Ensure signer is available and get address
          if (!thisEthersSigner) {
            setMessage("Signer not available");
            return;
          }

          const signerAddress = await thisEthersSigner.getAddress();
          const input = instance.createEncryptedInput(
            thisPowerUsageAddress,
            signerAddress
          );
          // Convert float to integer (multiply by 100 to preserve 2 decimal places)
          // e.g., 150.9 kWh -> 15090 (stored as integer)
          const usageValueInt = Math.round(powerUsageValue * 100);
          input.add32(usageValueInt);

          const enc = await input.encrypt();

          if (await isStale()) {
            setMessage("Operation cancelled");
            return;
          }

          setMessage("Submitting to blockchain...");

          const contract = new ethers.Contract(
            thisPowerUsageAddress,
            powerUsage.abi,
            thisEthersSigner
          );

          const tx = await contract.addRecord(
            enc.handles[0],
            enc.inputProof,
            period
          );

          setMessage(`Waiting for transaction: ${tx.hash}...`);
          await tx.wait();

          setMessage("Record submitted successfully!");
          await loadUserRecords();
        } catch (e: any) {
          const errorMessage = e?.message || String(e);
          // Check if it's a relayer connection error
          if (errorMessage.includes("Relayer") || errorMessage.includes("relayer") || errorMessage.includes("Bad JSON")) {
            setMessage("Relayer service temporarily unavailable. Please try again in a few moments. If the problem persists, check Zama community status.");
          } else {
            setMessage("Failed to submit record: " + errorMessage);
          }
        } finally {
          isSubmittingRef.current = false;
          setIsSubmitting(false);
        }
      };

      run();
    },
    [
      powerUsage.address,
      powerUsage.abi,
      instance,
      ethersSigner,
      chainId,
      loadUserRecords,
      sameChain,
      sameSigner,
    ]
  );

  const decryptRecord = useCallback(
    async (recordId: number) => {
      if (!powerUsage.address || !instance || !ethersSigner) return;

      const record = records.find((r) => r.recordId === recordId);
      if (!record || record.encryptedUsage === ethers.ZeroHash) return;

      setIsDecrypting(recordId);
      setMessage(`Decrypting record ${recordId}...`);

      try {
        const sig: FhevmDecryptionSignature | null =
          await FhevmDecryptionSignature.loadOrSign(
            instance,
            [powerUsage.address as `0x${string}`],
            ethersSigner,
            fhevmDecryptionSignatureStorage
          );

        if (!sig) {
          setMessage("Unable to build decryption signature");
          return;
        }

        const res = await instance.userDecrypt(
          [{ handle: record.encryptedUsage, contractAddress: powerUsage.address }],
          sig.privateKey,
          sig.publicKey,
          sig.signature,
          sig.contractAddresses,
          sig.userAddress,
          sig.startTimestamp,
          sig.durationDays
        );

        // Convert integer back to float (divide by 100)
        // e.g., 15090 -> 150.9 kWh
        const decryptedValueInt = Number(res[record.encryptedUsage]);
        const decryptedValue = decryptedValueInt / 100;

        setRecords((prev) =>
          prev.map((r) =>
            r.recordId === recordId ? { ...r, decryptedValue } : r
          )
        );

        setMessage(`Decrypted: ${decryptedValue} kWh`);
      } catch (e) {
        setMessage("Failed to decrypt: " + e);
      } finally {
        setIsDecrypting(null);
      }
    },
    [powerUsage.address, instance, ethersSigner, records, fhevmDecryptionSignatureStorage]
  );

  return {
    contractAddress: powerUsage.address,
    records,
    canSubmit,
    canLoadRecords,
    submitRecord,
    decryptRecord,
    loadUserRecords,
    isLoading,
    isSubmitting,
    isDecrypting,
    message,
    isDeployed,
  };
};


